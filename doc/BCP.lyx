#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\end_header

\begin_body

\begin_layout Title
BCP/ConcurrenTree Basics
\end_layout

\begin_layout Paragraph
This document is a continuous process of flux and being fleshed out.
 Direct any questions or complaints to Philip Horger at campadrenalin@gmail.com.
\end_layout

\begin_layout Part
ConcurrenTree Model
\end_layout

\begin_layout Standard
ConcurrenTree is a concurrent text technology that puts live text editing
 in everybody's hands with its simplicity, especially compared to competitors
 like Operational Transform.
 CTree code is easy to write, easy to port, and doesn't have algorithmic
 ambiguity.
\end_layout

\begin_layout Section
Trees
\end_layout

\begin_layout Standard
Trees are a fairly simple data structure at the core of ConcurrenTree.
 Just about every operation you can perform on a CTree document will traverse
 and/or modify trees, so it's good to get a nice solid understanding of
 them before rushing into the rest of this documentation.
 I mean, you can if you want, but you should learn to walk before you run,
 grasshoppa.
\end_layout

\begin_layout Standard
A tree consists (most importantly) of an immutable string and a boolean
 array called the 
\begin_inset Quotes eld
\end_inset

deletions array.
\begin_inset Quotes erd
\end_inset

 There's a boolean in the array for every character marking whether it's
 deleted or not.
\begin_inset Foot
status open

\begin_layout Plain Layout
One might ask why we don't just, you know, actually delete characters instead
 of having an immutable string.
 Good question, and there's a lot of interesting theory behind that - but
 it's mostly beyond the scope of this document.
 The headlines: we need to maintain our index positions in the face of deletions
, storing a char is basically as efficient as marking it deleted anyways,
 and it allows for consistent hashing throughout the lifetime of the tree.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The tree has a few more properties we have to worry about, though.
 The next biggest one (importance-wise, I mean) is the tree's children.
 The most conceptually accurate way to do this is as an array of string-key
 dictionaries, but there's nothing stopping you from finding more space-
 or memory-efficient ways to do it.
 What you're trying to model here is the fact that any arbitrary number
 of child trees can be attached to any index position
\begin_inset Foot
status open

\begin_layout Plain Layout
An index position represents a space between characters or on either end
 of the full string.
 So it can be any integer between (and including) 0 and 
\emph on
n
\emph default
 for a string of length 
\emph on
n.
\end_layout

\end_inset

 in the parent tree, and it can be found again given the hash of its original
 value and the index it's attached to.
\end_layout

\begin_layout Standard
Using these properties, we have a working plaintext model for which we can
 write algorithms that insert text (by adding children), delete text (by
 applying deletions), 
\begin_inset Quotes eld
\end_inset

export
\begin_inset Quotes erd
\end_inset

 the tree to a single resultant string, and convert a position in the resultant
 string to a position in the tree or its children.
 Expect a lot of recursion when we get to the algorithm section.
 If you don't like recursion, then tough, it's a fundamental programming
 concept and the right tool for this kind of job.
\end_layout

\begin_layout Standard
Finally, we have markers.
 Markers handle formatting in a way that gets out of the way of regular
 text (important for concurrently edited documents) and makes a very simple
 kind of sense.
 Things get a bit nastier and dirtier under the hood to maintain eventual
 consistency though, which is one of the key properties of ConcurrenTree.
 So we'll get into the inner workings a bit later, but for now, here's markers
 in a nutshell: a marker has a type, a value, and a position, and it applies
 to everything to the right of it in the resultant text, at least until
 another marker of the same type shows up.
\end_layout

\begin_layout Section
Addresses
\end_layout

\begin_layout Standard
There are two types of addresses, 
\emph on
absolute
\emph default
 and 
\emph on
shorthand
\emph default
.
 Absolute addresses are conceptually simpler, so you can learn those now,
 build on that knowledge, and then learn the shorthand variation later on
 when you learn about eras.
\end_layout

\begin_layout Standard
The basic idea of an address is not as complicated as it sounds.
 We want to be able to reference any node in a complex tree with a string.
 And we can! The best part is we borrow a little syntax from filesystem
 syntax to make it intuitive and familiar.
\end_layout

\begin_layout Quote
0:a98321/4:393bf8/1:de73c0
\end_layout

\begin_layout Standard
As you might have guessed from our example, each node is referenced with
 an index:hash combination, the / denotes a parent-child relationship, and
 we can see that a tree with a hash of 393bf8 is a child of root node 0:a98321
 at index 4.
\end_layout

\begin_layout Standard
Here's how it works.
 Any node can find any of its children given an index and a hash.
 A recursive algorithm can pass a request down a tree and bring the answer
 to the top by having each node pop a child off the front of it, so each
 node gets an address to resolve that's a little shorter, until finally
 the correct node is found and passed back up with return statements.
\end_layout

\begin_layout Section
Instructions and Operations
\end_layout

\begin_layout Standard
One thing that CTree borrows from its 
\emph on
very
\emph default
 distant ancestor OT is the notion of instructions and operations.
 However, some neat properties of CTree make them a lot simpler.
 Operations never need to be 
\begin_inset Quotes eld
\end_inset

tranformed
\begin_inset Quotes erd
\end_inset

, they can be applied on any machine in any state or queued until their
 dependencies are satisfied.
 It's even okay to do stuff more than once, since everything is designed
 to be idempotent - multiple applications of the same operation have the
 same effect as one.
\end_layout

\begin_layout Standard
But I'm getting ahead of myself.
 If you're reading this, you're probably new to the party.
 So don't panic, this stuff is simpler than it sounds.
\end_layout

\begin_layout Standard
Instructions are individual actions you can on a tree given an address and
 a few other parameters.
 Basically, the kind of stuff that takes one function call.
 Insert a child to a node, delete characters from a node, marker stuff,
 etc.
 So there's not too many types of instructions to worry about, and we'll
 get into them individually with sample algorithms soon enough.
\end_layout

\begin_layout Standard
An operation is a sequence of instructions.
 You can write functions that analyze the instructions to figure out the
 dependencies of an operation (what nodes have to be in a tree before the
 operation makes sense/can be applied), you can operation merging functions,
 but ultimately, an operation is a vector.
 Nothing more, nothing less.
\end_layout

\begin_layout Standard
So, you might be wondering why we even bothered to use terminology for this
 stuff.
 The reason is serialization.
 Instructions and operations can be serialized to JSON in a consistent fashion
 that allows them to be transferred between machines and applications, and
 quite importantly, can be hash-checked to see if it's already been applied.
\end_layout

\begin_layout Standard
But no worries if it's got overlap with stuff you've already applied to
 your tree! A few CPU cycles wasted, but no harm done.
 Everything will merge together correctly and not increase memory usage
 with the overlap.
\end_layout

\begin_layout Section
Eras
\end_layout

\begin_layout Standard
ConcurrenTree's magic 
\begin_inset Quotes eld
\end_inset

secret
\begin_inset Quotes erd
\end_inset

 formula is that on a conceptual level, information cannot be deleted.
 It can only increase or overwrite in fairly non-destructive ways.
\end_layout

\begin_layout Standard
Yeah, that look of horror and the memory usage panics running through your
 head are normal.
 We had 'em too during the development process.
 It sounds like the data storage requirements of a single document would
 eventually spiral out of control, especially in live-typing situations
 where you very quickly get deeply-structured trees of small nodes with
 a scary overhead-to-data ratio.
\end_layout

\begin_layout Standard
Well, the good news is that we fixed it.
 The bad news is that the fix is one of the more difficult concepts in Concurren
Tree.
 It's called an 
\begin_inset Quotes eld
\end_inset

era.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Every tree heirarchy can be thought of as being in layers.
 Let's use directories as an example.
 
\emph on
/
\emph default
 is at layer 0, 
\emph on
/dev
\emph default
 and 
\emph on
/bin
\emph default
 are on layer 2, and 
\emph on
/var/lib/alsa
\emph default
 is on the same layer as 
\emph on
/home/philip/documents
\emph default
 even though they're distantly diverged in the tree.
\end_layout

\begin_layout Standard
In the same way, you can think of CTree documents as having layers (although
 unlike our directory example, layer zero can have as many nodes as you
 want, there is no top-level node).
 For every 16 layers
\begin_inset Foot
status open

\begin_layout Plain Layout
Why 16? Well, it was an arbitrary decision.
 We decided it was a nice power of two about the right size for it.
 Theoretically, we could use any era size, but then you wouldn't have the
 nice symmetry with hexadecimal numbers (for example, era 0 starts at 00,
 era 1 starts at 10, era 2 at 20, and so on).
\end_layout

\end_inset

 in a document, there's an era.
 Layer 15 is the last layer in era 0, layer 16 is the first in era 1.
 Or, if you like hexadecimal, layer 0F is the last layer in era 0, and layer
 10 is the first in era 1.
\end_layout

\begin_layout Standard
So, we've organized our layers into bigger segments, but we haven't solved
 any memory crises quite yet.
 But we're getting there.
 You see, at each era border, we can collapse all previous eras into a single
 
\begin_inset Quotes eld
\end_inset

virtual node
\begin_inset Quotes erd
\end_inset

 called a flat, allowing us to treat unlimited structural data like a single
 node.
\end_layout

\begin_layout Standard
This voodoo is accomplished with more or less the same algorithms used to
 convert a tree into a resultant string.
 This lets us scale 
\emph on
down
\emph default
 our memory usage.
 We can also scale it back 
\emph on
up
\emph default
 as needed if we get an operation that operates on nodes above our copy's
 flatline, by requesting that information from the hard drive cache or the
 web.
 Era algorithms let us plug in higher eras to our stack and move the flatline
 in either direction at will.
\end_layout

\begin_layout Section
Shorthand Addresses
\end_layout

\begin_layout Standard
So now that you understand eras (or at least enough to nod your head and
 pretend you do), you can now understand shorthand addresses.
\end_layout

\begin_layout Standard
On deep trees (let's say, 80 layers deep), absolute addresses are just gonna
 be unmanageably large.
 With about 12 characters per layer minimum...
 that's 96 characters.
 Not so bad on its own, but addresses are used everywhere, and that's a
 lot of overhead, and it's assuming fairly short hashes.
\end_layout

\begin_layout Standard
The answer to this is a special type of address that lets us shortcut to
 certain nodes - say, any node on the first layer of any era.
 It's not too complicated to do this.
\end_layout

\begin_layout Standard
The shortcut format is 
\begin_inset Quotes eld
\end_inset

#738bbe95
\begin_inset Quotes erd
\end_inset

, where the number is the hash of it's shortcut address from the next shortcut
 up the tree.
 For era 1 shortcuts, this is just their absolute address, for era 2 it's
 the shortcut from their era 1 ancestor, etc.
 From there you can add on normal 
\begin_inset Quotes eld
\end_inset

/index:hash
\begin_inset Quotes erd
\end_inset

 segments to move further down the tree.
\end_layout

\begin_layout Standard
This is a little more complicated than always using the absolute address,
 but it allows for gradual 
\begin_inset Quotes eld
\end_inset

forgetting
\begin_inset Quotes erd
\end_inset

 of ancient eras.
\end_layout

\begin_layout Part
Algorithms
\end_layout

\begin_layout Standard
The ConcurrenTree model is designed so that you can figure out algorithms
 from scratch correctly without a reference, but it's still useful to have
 some examples, especially for stuff like markers.
 These algorithms to not do any sanity or validity checking, for the sake
 of simplicity, so while they may be easier to read than the source code
 in the repository, they're also a bit brittle, and for educational purposes
 only.
\end_layout

\begin_layout Section
find
\end_layout

\begin_layout Standard
This resolves an address to a node object in memory using recursion.
 It's the foundation of other document-level algorithms.
\end_layout

\begin_layout Quote
tree::resolve(string address) {
\end_layout

\begin_deeper
\begin_layout Quote
// isolate top-level piece
\end_layout

\begin_layout Quote
string top = everything to the left of the first 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Quote
address = everything after it
\end_layout

\begin_layout Quote
tree next;
\end_layout

\begin_layout Quote
if top[0] == 
\begin_inset Quotes eld
\end_inset

#
\begin_inset Quotes erd
\end_inset

 {
\end_layout

\begin_deeper
\begin_layout Quote
// shortcut address
\end_layout

\begin_layout Quote
next = document.shortcuts[top];
\end_layout

\end_deeper
\begin_layout Quote
} else {
\end_layout

\begin_deeper
\begin_layout Quote
int index = top.split(
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

)[0]
\end_layout

\begin_layout Quote
string child = top.split(
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

)[1]
\end_layout

\end_deeper
\begin_layout Quote
}
\end_layout

\end_deeper
\begin_layout Quote
}
\end_layout

\begin_layout Section
trace
\end_layout

\begin_layout Standard
The trace algorithm takes a position in a resultant string and converts
 it into an (address, index) pair representing an index position in a specific
 node.
 This allows you to do all your other operations in result-space, for example,
 inserting text to a position in the displayed resultant text.
\end_layout

\begin_layout Standard
While it's one of the most fundamentally useful algorithms, it's also one
 of the most complicated.
\end_layout

\begin_layout Part
BCP Basics
\end_layout

\begin_layout Standard
Basic ConcurrenTree Protocol is a protocol specification for transferring
 and syncronizing CTree documents.
 The syntax is not too hard to learn - it's just a bidirectional stream
 of JSON objects called 
\begin_inset Quotes eld
\end_inset

messages.
\begin_inset Quotes erd
\end_inset

 Each message always has a required property called 
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
BCP can be used over any stream where packet order can be guaranteed, for
 example TCP sockets.
 For browser-based CTree systems, one might find a lot of usefulness with
 Socket.IO, Node.js, and the Javascript library provided in the ConcurrenTree/Orch
ard repository.
\end_layout

\begin_layout Standard
If you want to write your own BCP interpreter in your language of choice
 (and good for you, you awesome person), you're gonna find the BCP Message
 Set reference document in the repository 
\emph on
very
\emph default
 handy.
 It details every message type with examples and everything, and even if
 you're just going to use an existing BCP library, you might find it interesting
 reading to see how things work under the hood.
\end_layout

\end_body
\end_document
